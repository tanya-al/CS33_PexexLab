1. The result was not correct because of the way LISP objects (and ints) are stored in C. The lowest two bits consist of a tag to differentiate what type of LISP object is given (pointer, char, int, etc.). So, our machine code must perform an lea 0x0(,%rbp,4),%rax to left shift by two to put the value into a LISP object and sar $0x2,%rdi later to sign extend only the int part of the object into a full 64 bits again. This means that the LISP object will overflow for values greater than 2^61-1, which are still less than 2^64-1. For these values, the object overflows, and the arithmetic right shift does not restore the correct value, but rather gives us an incorrect int value which we then use in our multiplication. This means that we do not multiply the correct numbers, so our answer is incorrect. In the given example, the final multiplication is the problem because that is where we grow larger than 2^61-1 in magnitude and the LISP object overflows.

2. The number 2305843009213693951 is actually the value 2^61-1. This value is printed because the defined value of most-positive-fixnum is to emacs/Lisp as INT_MAX is to C++. A fixnum is an integer that fits in a word of memory (including the tag bits). For a 64-bit architecture and 2 bit tags in our LISP objects, we are left with 61 bits in which to actually store our number. So, the largest positive fixnum is 2^61-1 = 2305843009213693951.

3. most-positive-fixnum * most-positive-fixnum should have the bit representation of 1100000000000000000000000000000000000000000000000000000000000001. But, we left shift and then right shift by 2 to fit this value in a LISP object with 2 bits of tags, so it becomes 0000...0001. When we return, we only see the value 1 as the top 2 bits got truncated off.

4. Our current code does checks for overflow already. Adding -fsanitize=undefined would simply generate machine code to insert more checks and jump to the ubsan handler functions we saw earlier in this lab, then jump back and go through emacs pre-existing overflow checks. This won't cause any problems with our trace, but it will make it more inefficient.

5. Using frwrapv will make our overflow checks essentially void, because fwrapv will allow wrap-around to happen and will just return the wrong multiplicative answer, without any errors in our trace/compilation/running of the program.

6. If we use fwrapv and just wrap around everytime we overflow, we can remove the overflow checks (INT_MULTIPLY_OVERFLOW) from the Emacs source code, and avoid generating many instructions of machine code for every argument that gets passed in to check for overflow. This will shorten both the source and machine code by quite a bit, depending on how many arguments we have/how many times the lines to check overflow are called in a specific program run.

7. For only a few arguments of multiplication, the tradeoff is relatively small; however, for a large number of arguments to be multiplied, removing several lines of machine instructions per multiplication step would add up to a lot of saved time and fewer wasted instructions (assuming fwrapv). So, in these cases, the efficiency would definitely improve.
